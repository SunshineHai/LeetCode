
""":arg
    继承：
        class <类名>(BaseClass, ...):
            <语句组>
        通过继承定义出的新类称为 派生类(或者 字类)，
        被继承的已有类，称为 基类(或者 父类)，一个新定义的 派生类 可以继承多个 基类。

        (BaseClass, ...), 括号里面的"参数"是指定的基类，可以有一个或多个。
"""

class MyStr(str):
    ''':arg
        MyStr 类 继承了 str 类，派生类里面没有任何操作
    '''
    pass

# issubclass(cls1, cls2) : 判断 cls2 是否为 cls1 的基类(父类)，若是，则返回 True，否则返回 False
s = MyStr(1234)             # 创建 MyStr 类型的对象
print(issubclass(MyStr, str))
print(isinstance(s, MyStr))
print(isinstance(s, str))   # 派生类对象也是基类的对象

""":arg
    派生类经常需要重新定义 __init__ 函数，完成该类实例的初始化。
    常见情况是要求 派生类的对象可以作为基类的对象，用在要求基类对象的环境中。
    
    1.常见形式：
    
    class DerivedClass(BaseClass):
        def __init__(self, ...):
            BaseClass.__init__(sefl, ...) # 调用 基类(父类) 的 __init__ 函数
            .......     # 初始化的其他操作
        # 派生类的其他语句和函数定义
    
    以上语句，初始化时调用 基类 的 __init__ 方法，对基类对象的所有 数据属性（成员变量）进行初始化。
    
    2.方法查找
    派生类的实例对象调用一个方法时，派生类和父类都有该方法时或者仅有一方有该方法，该怎样寻找哪？
    如果从一个派生类的实例对象出发去调用方法，Python 解释器需要确定应该调用按个函数。
    查找过程是 从该实例对象所属的类开始查找，没有找到则查找该实例对象对应类的基类中查找，如果最终都没有
    查找到函数属性，那就是属性无定义。
    
"""


class B:
    def f(self):
        self.g()

    def g(self):
        print('B.g called.')    # 基类(父类)中定义有 g() 方法


class C(B):                     # 派生类 C 继承 基类 B
    def g(self):                # 派生类中 也定义了 g()
        print('C.g called.')


x = B()             # 创建 B 的实例对象 x
x.f()               # 调用 f() 函数

y = C()             # y 是 类C 的实例对象
y.f()               # 此时类B中的f() 里的 g() 是调用 类B 还是 类C 里的哪？
''':arg
    3.静态约束 和 动态约束
    
    执行情况：y 是 类C 的实例化对象，Python解释器先从 类C 中查找f(), 一遍之后没有找到，则去基类
    B 中去查找，查找到之后，则执行 基类的 f() 方法， 此时出现问题：
    基类 f() 里有一个 g(),我们该执行 类B 还是 类C 里的 g() 哪？
        1.因为 y 是 类C 的实例对象，因为 派生类中没有 f() ，则调用 基类中的f()
        2.基类中的self则指向是实例对象 y, 因此 self.g() 即是调用 y.g(),故调用 C类中的g() 方法。
    以上即是 动态约束(大多数面向对象的语言都是这样的)。
    
    静态约束(静态绑定)：上例中 self.g() 直接调用 类f 里的g()方法，则为静态约束。
    
    4.标准函数 super()
        Python 中提供了一个内置函数 super(), 就是要求从这个类的 直接基类开始做属性检索，而不是从这个类本身开始查找。
        采用 Super函数 而不是直接写基类名字，产生的查找更加的灵活。super() 函数的使用分为2种：
            1.不带参数的调用形式
                super().m(...)
                这种形式只能出现在方法函数的定义里，在函数调用时，当前实例将被作为被调用函数的self实参。
            2.带参数的调用
                super(C, obj).m(...)
                这种写法要求从指定的类C的基类开始查找函数属性m, 调用里出现的 obj
                必须是类C的一个实例。Python解释器找到函数m，将用 obj 作为该函数
                的self实参。这种写法可以出现在程序的任何地方，并不要求一定出现在类的方法函数里。      
'''


class C1:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def m1(self):
        print(self.x, self.y)


class C2(C1):
    def m1(self):
        super().m1()            # 从基类查找 函数 m()
        print("这是派生类")


c = C2(10, 20)      # class C2 没有定义 init方法，初始化时直接调用 基类 C1 的init方法
c.m1()              # 调用 class C2 的 m1()

